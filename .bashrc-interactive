#!/bin/bash

if test "$EMACS" != t; then
    if test -e /etc/bash_completion; then
        . /etc/bash_completion
    elif test -e /opt/local/etc/bash_completion; then
        . /opt/local/etc/bash_completion
    fi
fi

for x in ~/.bash_completion.d/*; do
    . "$x"
done

function cd_bhj ()
{
    local oldpwd=`pwd`
    local ok=1 # 1 means not ok
    lcd "$@" && return $?

    test $# == 1 -o $# == 0 && builtin cd "$@" >/dev/null 2>&1 || cd_failed "$@" && ok=0 # 0 means ok
    return $ok
}

function cd_failed()
{
    local IFS=$'\n'
    dirs=( $(where "$@") )
    if test ${#dirs[@]} = 0; then
        echo 'Error: no such file or directory'
        return 1
    elif test ${#dirs[@]} = 1; then
        builtin cd ${dirs[0]}
    else
        NUM=`my-select "${dirs[@]}"`
        ((NUM--))
        builtin cd "${dirs[$NUM]}"
    fi
    return 0
}

function fcd()
{
    local IFS=$'\n'
    dirs=( $(find . -iname "*$1*") )
    if test ${#dirs[@]} = 0; then
        echo 'Error: no such file or directory'
        return 1
    elif test ${#dirs[@]} = 1; then
        cd_bhj ${dirs[0]}
    else
        NUM=`my-select "${dirs[@]}"`
        ((NUM--))
        cd_bhj "${dirs[$NUM]}"
    fi
}

function wcd()
{
    local IFS=$'\n'
    dirs=( "$@" )
    if test ${#dirs[@]} = 0; then
        echo 'Error: no such file or directory'
        return 1
    elif test ${#dirs[@]} = 1; then
        cd_bhj ${dirs[0]}
    else
        NUM=`my-select "${dirs[@]}"`
        ((NUM--))
        cd_bhj "${dirs[$NUM]}"
    fi
}

function fp()
{
    f "$@" | tee /dev/stderr | putclip
}

function fe()
{
    f "$@" | xargs e
}

function rbcd()
{
    dirs=(`repo branches|perl -npe 's/.* in\b.//; s/,/ /g; s/ /\n/g'|sort -u`);
    NUM=`my-select "${dirs[@]}"`
    ((NUM--))
    cd_bhj "${dirs[$NUM]}"
}

function re()
{
    echo 'error: re should never be executed!'
}

function rex()
{
    command rex "$@" ~/.bash_history.bak
}

function rcd() {
    if test $# = 0; then
        cd .repo/manifests
    else
        scd "$@"
    fi
}

function rsync() {
    local x
    local -a args=()
    local -a saved_args=("$@")
    local last_arg=${saved_args[$# - 1]}


    local n=0
    for x in "$@"; do
        ((n++))
        if test "${x:0:1}" != -; then
            need_ask=false
            if test $n != $# -a "${x:${#x}-1}" = /; then
                need_ask=true
            fi
            if test $((n + 1)) = $# -a "${x:${#x}-1}" = / -a "${last_arg:0:1}" = -; then
                need_ask=false
            fi
            if test $need_ask = true && { test -d "$x" || yes-or-no-p -y "Remove the trailing / for $x?"; };  then
                if test -d "$x"; then
                    echo removing / from the end of $x 1>&2
                fi
                args=("${args[@]}" "${x%/}")
                continue
            fi
        fi
        scp=/scp:
        if test "${x:0:${#scp}}" = /scp:; then
            x=${x#/scp:}
        fi
        args=("${args[@]}" "${x}")
    done
    set -- "${args[@]}"
    command rsync "$@"
}

. ~/bin/.gitx

if test -e ~/.bashrc-interactive-$USER; then
    . ~/.bashrc-interactive-$USER
fi
